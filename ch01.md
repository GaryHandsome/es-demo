## 第一章 - JavaScript核心组成

>- ECMAScript：核心语法（新特性）
>- Vue
>- Vant
>- 前后端分离
>
> ajax + layuiadmin

### 一、概述













JavaScript（简称JS）是一种轻量级、解释型、动态类型的高级程序设计语言。



#### 1、组成

JavaScript = ECMAScript  + DOM（文档对象模型）+ BOM（浏览器对象模型）

- ECMAScript：定义了语言的语法、类型、语句、关键字、保留字、操作符、对象等核心内容。

- DOM（Document Object Model）：定义了处理网页内容的方法和接口。

- BOM（Browser Object Model）：定义浏览器进行交互的方法和接口。



#### 2、JavaScript与ECMAScript之间的关系

ECMAScript是标准，JavaScript是ECMAScript的实现



#### 3、特点

- 解释型的脚本语言

- 基于对象

- 事件驱动

- 跨平台

- 安全性

- 弱类型



### 二、ECMAScript

宿主：比如，寄生虫寄生在人体这个环境才可以生存。这里的人体就是宿主环境。

这里的ECMAScript及相关的ECMAScript实现（JavaScript）也像寄生虫一样，需要一个宿主环境才可以运行。这个宿主环境一般是浏览器。



### 三、数据类型

#### 1、基本数据类型

- number：数值型类型，包括int,long,double,float,short

- string：字符串类型，注：字符串使用单引号或双引号引住

- boolean：布尔类型，它只有true或false两个值

- undefine：没有定义类型，当定义一个变量，且没有给变量赋值

- null：空类型，使用了一个不存在对象



通常，数值、字符串、布尔值这三种类型，合称为原始类型，它们是最基本的数据类型，不能再细分；

 

而undefine和null，我们可以看成是两个特殊的数值



#### 2、对象类型

- 狭义的对象（object）

- 数组（array）

- 函数（function）



引用数据类型，也称之为对象类型或合成类型。因为一个对象往往由多个原始类型组成；

 

狭义的对象和数组是两种不同的数据组合方式；

 

函数其实是处理数据的方法，JavaScript 把它当成一种特殊的数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 JavaScript 的“函数式编程”奠定了基础。

```javascript
function fun() {
    
}

var fun = function() {
    
}

var age = 100 ;
```



### 四、语法要点

#### 1、typeof运算符

用于查看数据或变量的数据类型

```js
var age = "你好" ;

// 返回数据类型的字符串表示
var type = typeof age ;

console.log(type)
```



#### 2、instanceof运算符

> 语法：object instanceof constructor

- 用来检测constructor.prototype是否存在于参数object的原型链上

- 简单理解，用于判断对象是否用指定的构造器函数创建

```javascript
// 定义一个函数
function Student() {

}

// 实例化对象
var zs = new Student();
var ls = new Array() ;

// 判断 zs 这个对象是否由 Student这个函数构造出来
var bl1 = zs instanceof Student ;
var bl2 = ls instanceof Student ;

// 结果为：true,false
console.log(bl1,bl2)
```



#### 3、undefind

使用没有赋值的变量



#### 4、特殊的boolean类型

- null：false

- undefined：false

- boolean：保持原值

- number：+0、-0、NaN、0.0为false、其它为true

- string：空字符串为false，其它为true

- object：true

```javascript
!stu 
```



#### 5、== 与 ===

- ==：数值比较（会进行类型转换）

- ===：数值比较 && 类型比较（不会进行类型转换）

```javascript
console.info("5" == 5) 			// true
// 更严紧、更苛刻
console.info("5" === 5) 		// false
```



#### 6、逻辑或的特殊使用

在JavaScript中，当进行逻辑运算时，没有严格要求参与运算的操作数必须为boolean类型的数据，运算的结果也不一定为boolean类型的数据。

```javascript
// true，操作数abc并不是boolean类型的数据(参照上面，非空字符串为true)
console.info("abc" && true) ;

// 当进行逻辑或运算时，如果操作数是boolean类型的数据，则结果为正常的boolean值;
console.info(true || 200 < 20) ; // true

// 当操作数为非boolean型数据时，如果第一个操作数为true（参照上面特殊的boolean型数据），则返回第一个操作数，否则返回第二个操作数。
var name = "tom" ;
console.info(s || "匿名") ;			// 匿名
console.info(name || "匿名") ;		// true,tom

var event = window.event || arguments[0] ;
```



### 五、严格模式

#### 1、概述

在ECMAScript5中，增加了**严格模式**，它采用具有限制性JavaScript变体的一种方式，从而使代码显示地 脱离“马虎模式/稀松模式/懒散模式“（sloppy mode）模式。

- 严格模式通过**抛出错误**来消除了一些原有**静默错误**。

- 严格模式修复了一些导致 JavaScript引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下**运行得更快**。

- 严格模式**禁用了**在ECMAScript的未来版本中可能会定义的一些语法。

- 严格模式使JavaScript更加规范，减少了语法中一些不合理、不严谨、怪异的地方；它可能会增加你写代码的难度，因为你熟悉的那些语法可以不能用了。



#### 2、开启严格模式

**方式一：为脚本开启严格模式**

使用"use strict"或'use strict'放在脚本的第一行，则使整个脚本或文件将以严格模式执行JS代码。

```html
<script>
  	// 在当前script中，使用严格模式
  	"use strict"
    
  	var str = "严格模式" ;
  	console.info(str) ;
</script>

<script>
  	// 另一个script，默认为非严格模式（sloppy mody），不受上面script的影响
  	str  = "非严格模式" ;
  	console.info(str) ;
</script>
```





**方式二：为函数开启严格模式**

```javascript
<script>
	function fun1() {
  	//在当前函数中，使用严格模式
  	"use strict"
  	var str = "严格模式" ;
  	console.info(str) ;
  }
  
  function fun2() {
  	//另一个script，默认为非严格模式（sloppy mody），不受上面函数影响
  	var str = "严格模式" ;
  	console.info(str) ;
  }
</script>
```

区别于方式一：作用范围不一样





### 六、异常处理

#### 1、语法

```javascript
try {
 	// 可以异常的代码 
} catch(e) {
  	// 发生异常时，执行的代码
} finally {
  	// 异常与否都会被执行的代码
}
```



#### 2、异常种类

ECMA-262 定义了下列 7 种错误类型，简单说明如下：

- Error：普通异常。通常与 throw 语句和 try／catch 语句一起使用。 利用属性 name 可以声明或了 解异常的类型，利用 message 属性可以设置和读取异常的详细信息。

- EvalError： 在不正确使用 eval（）方法时抛出。

- SyntaxError：抛出语法错误。

- RangeError：在数字超出合法范围时抛出。

- ReferenceError：在读取不存在的变量时抛出 。

- TypeError：当一个值的类型错误时抛出该异常。

- URLError：由 URL 的编码和解码方法抛出。

其中 Error 是基类，其他错误类型都继承自该类型。因此，所有错误类型共享了一组相同的属性， 错误对象中的方法全是默认的对象方法。 Error 类型的错误很少见，如果有也是浏览器抛出的，这个基类型的主要目的是供开发人员抛出自定义错误。



#### 3、自定义异常

```javascript
<script>
  function getAge( age ) {
    
    // isNaN(数据)：判断参数中的数据是否不是一个数值
    if(isNaN(age)) {
      // 自定义抛出异常
      throw {
        name:'TypeError',
        message:'类型错误，年龄必须是数字！'
      }
    }

    return age ;
  }

  // getAge('five') ;

  // 异常处理
  try {
    getAge('five') ;
  } catch(error) {
    console.info(error) ;
  }

</script>
```



#### 4、全局异常

太多的try-catch在代码中会使程序不够简洁，V8引擎不鼓励在函数中使用try-catch进行异常处理，而使用全局的错误处理`onerror`进行捕获。

**1）语法一**

```html
<script>
    // 全局异常处理
    window.onerror = function(message,source,lineno,colno,error){
        console.info("异常信息：" + message ) ;
        console.info("异常URL：" + source ) ;
        console.info("异常行号：" + lineno ) ;
        console.info("异常列号：" + colno ) ;
        console.info( error ) ;
        console.log("异常处理....")
        // 如果返回值为false，则在控制台 (JavaScript console) 
        // 中显示错误消息，反之则不会
        return true
    }

    // 调用一个不存在的方法
    window.do() ;

</script>
```



**2）语法二**

```html
<script>
    // 全局异常
    window.addEventListener('error',function( errorTarget ){
        console.info("异常处理...") ;
        console.log(errorTarget)
    });

    // 调用一个不存在的方法
    window.do() ;

</script>
```



### 七、DOM扩展

#### 1、选择符API

**1）querySelector()方法**

querySelector() 方法返回文档中匹配指定 **CSS 选择器** 的一个元素，没有则返回null。

**注意：** querySelector() 方法仅仅返回匹配指定选择器的第一个元素。如果你需要返回所有的元素，请使用 querySelectorAll() 方法替代。

```js
document.querySelector("CSS选择器") ;
```



**2）querySelectorAll()方法**

queySelectorAll() 方法返回文档中匹配指定 CSS 选择器的所有元素，返回 [NodeList](https://www.runoob.com/js/js-htmldom-nodelist.html) 对象。

NodeList 对象表示节点的集合。可以通过索引访问，索引值从 0 开始。

**提示:** 你可以使用 NodeList 对象的 [length](https://www.runoob.com/jsref/prop-nodelist-length.html) 属性来获取匹配选择器的元素属性，然后你可以遍历所有元素，从而获取你想要的信息。

```javascript
var nodeList = document.querySelectorAll("CSS选择器");
```



#### 2、classList属性

classList 属性返回元素的类名，作为 DOMTokenList 对象；



该属性用于在元素中添加，移除及切换 CSS 类；



classList 属性是只读的，但你可以使用 add() 和 remove() 方法修改它。



```js
var classList对象 = 节点对象.classList ;
```





- 属性

| 属性   | 描述                                  |
| ------ | ------------------------------------- |
| length | 返回类列表中类的数量 ，该属性是只读的 |



- 方法

| 方法                          | 描述                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| add(*class1, class2, ...*)    | 在元素中添加一个或多个类名。  如果指定的类名已存在，则不会添加 |
| contains(*class*)             | 返回布尔值，判断指定的类名是否存在。 可能值： true - 元素包已经包含了该类名 false - 元素中不存在该类名 |
| item(*index*)                 | 返回元素中索引值对应的类名。 索引值从 0 开始。  如果索引值在区间范围外则返回 *null* |
| remove(*class1, class2, ...*) | 移除元素中一个或多个类名。   **注意：** 移除不存在的类名，不会报错。 |
| toggle(*class,* true\|false)  | 在元素中切换类名。   第一个参数为要在元素中移除的类名，并返回 false。 如果该类名不存在则会在元素中添加类名，并返回 true。  第二个是可选参数，是个布尔值用于设置元素是否强制添加或移除类，不管该类名是否存在。例如：   移除一个 class: *element*.classList.toggle("classToRemove", false);  添加一个 class: *element*.classList.toggle("classToAdd", true);   **注意：** Internet Explorer 或 Opera 12 及其更早版本不支持第二个参数。 |



#### 3、文档加载

`Document.readyState` 属性描述了`document` 的加载状态。

当该属性值发生变化时，会在 `document` 对象上触发 `readystatechange` 事件。

```js
var string = document.readyState;
```

`readyState` 有以下三种状态：

-  `loading`（正在加载）
  `document` 仍在加载。 

-  `interactive`（可交互）
  文档已被解析，"**正在加载**"状态结束，但是诸如图像，样式表和框架之类的子资源仍在加载。 

-  `complete`（完成）
  文档和所有子资源已完成加载。表示 `load` 状态的事件即将被触发。 

```javascript
// 当document.readyState状态改变时，会触发onreadystatechange事件
document.onreadystatechange = function () {
	console.info(document.readyState) ;
}
```



**监听文档各种状态**

```javascript
function initApplication() {
  switch (document.readyState) {
    case "loading":
      // 表示文档还在加载中，即处于“正在加载”状态。
      console.log("正在加载")
      break;
    case "interactive":
      // 文档已经结束了“正在加载”状态，DOM元素可以被访问。
      // 但是像图像，样式表和框架等资源依然还在加载。
      var span = document.createElement("span");
      span.textContent = "A <span> element.";
      document.body.appendChild(span);
      break;
    case "complete":
      // 页面所有内容都已被完全加载.
      console.log("加载完成")
      let CSS_rule = document.styleSheets[0].cssRules[0].cssText;
      console.log(`The first CSS rule is: ${CSS_rule}`);
      break;
  }
}

// 模拟 DOMContentLoaded/ jquery ready
document.onreadystatechange = function () {
  if (document.readyState === "interactive") {
    initApplication();
  }
}
```



#### 4、自定义data属性dataset

在开发中，我们可以给标签添加额外的属性，用于暂存数据，实现一些特殊的操作。如bootstrap中的data-toggle。

><标签 data-名称=值 ...> 内容 </标签>



获取data属性的名称和值

> 节点.dataset.名称



```html
<p id="gg" data-size="100" data-user="{name:'zs',age:18}">好好学习，天天向上</p>

<script>
  var p = document.querySelector("#gg") ;

// 100
console.info(p.dataset.size)

// 需要JSON格式的把data属性值，转换为JSON对象，否则输出undefined
console.info(p.dataset.user.name)

// 转换为JSON对象
var user = eval('(' + p.dataset.user + ')') ;

console.log(user.name)
console.log(user.age)

</script>
```



#### 5、scrollIntoView()方法

让当前的元素滚动到浏览器窗口的可视区域内。

> 节点.scrollIntoView([true|false]) ;

-  true：顶部对齐父元素 

-  false：底部对齐父元素 



```html
<style>
  ul {
    height: 70px;
    width:200px;
    overflow-y: scroll;
  }

  ul li {
    height: 25px;
    line-height: 25px;
  }
</style>

<ul>
  <li>对话1</li>
  <li>对话2</li>
  <li>对话3</li>
  <li>对话4</li>
  <li>对话5</li>
  <li>对话6</li>
  <li>对话7</li>
</ul>

<button id="btn">滚动到第5条对话</button>

<script>
  document.querySelector("#btn").onclick = function() {
    document.querySelectorAll("ul li")[4].scrollIntoView(true) ;
  }
</script>
```

