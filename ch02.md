## 函数

### 一、概述

函数是一些JavaScript代码的封装体，可以实现一些业务功能或职责；

在JavaScript中，函数是一流的对象（`函数是JavaScript中的一等公民`），因为它们可以像其他任何对象一样具有属性和方法。它们与其他对象的区别在于可以调用函数。简而言之，它们是`Function`对象。



### 二、分类

1. 预定义（系统）函数
2. 自定义函数
3. 特殊函数的用法



### 三、自定义函数

#### 1、语法一

```javascript
function 函数名([参数1,参数2,...,参数n]) {
  //函数体（语句块）： 函数功能的实现
  [return 数据;]
}

function aa(num1,num2) {
    
}

aa(100,"你好") ;
```



#### 2、语法二

```javascript
// 在JavaScript中，函数是一个特殊的数据
var 名称 = function([参数1,参数2,...,参数n]) {
  //函数体（语句块）： 函数功能的实现
  [return 数据;]
}
```



#### 3、语法三

```javascript
var 名称 = new Function('参数1','参数2',..,'参数N','函数体') ;

// 或

var 名称 = new Function('参数1,参数2,..,参数N','函数体') ;
```

说明：

1）函数的操作步骤

第一：定义函数（语法如上）

第二：使用函数

```javascript
 [var 变量 = ]函数名（[实参列表]） ; 	//变量用于接收返回值
```



2）函数的四个要素

- 函数名：函数的标识，便于用户通过此名称调用

- 参数（可有0个或多个参数，逗号分割） 

- - 形参(形式意义的参数)：函数声明时的参数，用于接收实参，形式意义的表示要处理的数据

- - 实参(实际意义的参数)：函数调用时传递的具体数据

- 函数体：函数功能的具体实现

- 返回值（0个或1个返回值）：函数处理的结果，返回到调用处，一般使用一个变量接收



3）arguments

在函数内部都存在一个对象——arguments，它有以下两种用法：

-  arguments数组 

- - 表示函数的参数：arguments[0]表示函数第一个参数、arguments[1]表示函数第二个参数，依次类推。

-  自调用函数 

- - arguments.callee

说明：

- arguments看上去像是一个数组，但实际上是一个类似数组的对象；它只是和数组相似，包含索引元素和length属性。它并没有数组提供的相关方法，如push()、sort()、slice()等，因此，它不是单纯数组。

```js
// 定义构造方法
function test() {
  // 错误，arguments对象中不存在push()方法
  arguments.push("hello") ;
  console.log(arguments);
}

test(1,2,3,4) ;
```

- 递归的使用





### 四、递归函数

#### 1、概述

简单的理解，在函数内，自己调用自己的函数，称之为递归函数。

注意：递归和循环类似，必须指定**退出递归的条**件，否则，会发生“栈溢出”错误。



#### 2、案例

**计算N的阶乘**

```javascript
// 第一：定义函数 - 业务、功能、职责
function fun(n) {
    // 定义退出递归的条件
    if(n==1) {
        return 1;
    }

    return n * fun(n-1) ;

}

// 第二：使用函数
var jg = fun(3) ;
console.log(jg)
```



### 五、函数的特殊使用

#### 1、函数是数据

#### 2、匿名函数

没有名称的函数



#### 3、回调函数

##### 1）概念

当你把函数A传递给函数B并且在B函数中执行A函数，这种情况经常称为A是一个回调函数；如果A没有名字，那么可称A为匿名回调函数。

> 简单理解，回调函数是方法参数的函数化。
>
> 或者，某个函数以参数的方式传递给另一个函数，并在那个函数执行此函数，这个函数就称之为回调函数。

```javascript
function fun(a,b) {
    return a + b() ;
}

function data() {
	return 200 ;    
}

//在这里，data是回调函数
fun(100,data) 

// 匿名回调函数的使用 - 常用
fun(100,function(){
    return 300 ;
}) 
```



#### 4、自调用函数

**在javascript中，函数在定义时，马上调用。我们称之为立即执行函数表达式（IIFE）**

```javascript
()();

;function([形参1,形参2,...]){
    // 函数具体功能的实现
})([实参1,实参2,...]);
```

注：

- 使用自调用的匿名函数的理由是做一些工作但不需要创建一些全局的变量。
- 一个缺点是，很明显就是你不能调用这个函数 2 次（除非你把它放在一个循环或者其它函数里面） 。这使得自调用的匿名函数非常适合做一次性或者初始化性质的工作。
- 为了避免与其它JavaScript代码产生冲突或影响，建议在自调用函数前加分号。



>大家先准备好，8：30开始...大家改个全名
>
>何振有 晚十分钟





#### 5、内部（私有）函数

在javascript中，函数可以定义在另一个函数里边（即嵌套定义）。因为在javascript中，函数是一个特殊的数据。

```javascript
function outer(data1) {

  // 内部（私有）函数：在函数内嵌套定义的函数 - 只能在定义函数的内部使用
  function inner(data2) {
    return data2 * 2 ;
  }

  let jg = data1 + inner(3) ;

  return "结果为：" + jg ;
}

console.log(outer(100)) ;
```



#### 6、返回函数的函数

一个函数总是会返回一个值，如果你没有显式的 return，那么就会隐式的返回undefined。一个函数只可以返回一个数据，并且这个数据当然也可以是一个函数。

```javascript
/*
	返回函数的函数：函数的返回值为函数，这样的函数称之为返回函数的函数

	思考：为什么函数的返回值可以为函数呢？  --- 在JavaScript中，函数就是数据（特殊）
*/
function a() {
  alert("AA") ;

  // 返回值为函数，因此a函数就是返回函数的函数
  return function() {
    alert("BB") ;
  }
}

// let fun = a() ;
// fun() ;

a()() ;
```





#### 7、函数，重写自己

因为一个函数可以返回一个函数，因此，我们可以通过函数的返回函数替换原函数这种方式来重写原函数的功能。如上例子中的函数，我们可以做这样的处理：

```javascript
function a() {
  //第一：在此可以实现一些初始化工作
  alert("AA") ;		
  
  //第二：在此可以实现函数具体的功能
  return function() {
    alert("BB") ;
  }
}

// 函数的"外部重写"，输出"AA"
a = a() ;		

// 再次调用a函数，输出"BB"
a() ;
```



函数重写，可以通过以下方式来操作（内部重写）

```javascript
function a() {
  alert("AA") ;	
  
  // 函数的内部重写
  a= function() {
    alert("BB") ;
  }
}
// 第一次调用a函数，输出“AA”
a() ;		

// 之后调用a函数，输出“BB”，a函数已经在内部被重写了！
a() ;
```



**综合案例**

```javascript
/*
		综合前面知识点
*/

// 自调用函数
// 语法一
// ;(function() {
//     alert("OK") ;
// })() ;

// 语法二：文本标记定义 + 自调用函数
// let aa = function(){
//     alert("OK") ;
// }() ;


let setup = 0 ;
// 自调用函数
let a = function() {

  // 内部（私有）函数 - 做一些初始化的工作（只做一次）
  function someSetup(){
    alert('AA-可以实现一些初始化工作') ;
    setup = 100 ;
  }

  // 内部（私有）函数 - 实现具体的业务功能（做N次）
  function actualWork(){
    alert('BB-实现具体的业务功能');
  }

  // 调用内部函数
  someSetup() ;

  // 返回函数的函数 - 重写了a函数
  return actualWork ;
}();

a() ;
a() ;
a() ;

console.log(setup)
```



#### 8、闭包

##### 1）概述

在理解闭包之前，必须先理解与闭包相关的两个重要概念：作用域链、词法作用域。



##### 2）作用域

JavaScript与很多程序设计语言不同，它不存在大括号级的作用域（**块级作用域**），但它有**函数作用域**。也就是说，在函数内定义的变量在函数外是不可见的；而变量如果在某代码块中定义（如：if、for中），该变量在代码块外仍然可见的。

```javascript
function f() {
  var a = 1 ;

  for(var i=1;i<=10;i++) {
    var k = 100 ;
    document.write("你好") ;
  }

  alert(i) ;	//变量i可以访问，11
  alert(k) ;	//变量k可以访问，100
}
f() ;				//调用函数
alert(a) ;	//错误，函数内的变量，函数外不能访问
```



##### 3）作用域链

```javascript
var a = 1 ;
function f() {
  var b = 2 ;
  function n() {
    var c = 3 ;
  }
}
```

注：在上面的代码中，函数n()既可以访问自身的变量c，也可以访问“父级”函数f()中的变量b，同时，还可以访问全局的变量a，这种形式就叫**“作用域链”**。



##### 4）词法作用域

在JavaScript中，函数是词法作用域的。也就是说，每个函数在被**定义时**（而非执行时）都会创建一个属于自己的环境（即作用域）。

```javascript
function f1() {
  var a = 1 ;
  f2() ;
}

function f2() {
  return a ;		//变量a在函数f2中并没有声明
}
f1() ;
```

**总结：**在函数**被定义时**（看定义时，而非运行时），该函数只能访问自身定义的变量、上级函数的变量以及全局变量。



##### 5）闭包

```javascript
var counter = function() {

  // 此变量i一直驻留在内存中
  var i = 0 ;

  return function() {
    return i++ ;
  }
  
}() ;

console.log(counter()) ;		// 0
console.log(counter()) ;		// 1
console.log(counter()) ;		// 2
```





### 六、Function对象

我们知道，函数是一个特殊的数据类型。但除了这还有别的——函数实际上是对象。有一个内置的构造器函数叫 Function()，它允许以另外一种方式创建函数。

> Math、string、Date













